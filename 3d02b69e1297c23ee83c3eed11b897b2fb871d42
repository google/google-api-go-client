{
  "comments": [
    {
      "key": {
        "uuid": "64303d13_4254122b",
        "filename": "googleapi/chunker.go",
        "patchSetId": 17
      },
      "lineNbr": 78,
      "author": {
        "id": 5505
      },
      "writtenOn": "2015-08-14T07:00:35Z",
      "side": 1,
      "message": "This no longer happens, right?",
      "revId": "3d02b69e1297c23ee83c3eed11b897b2fb871d42",
      "serverId": "c958e1eb-c711-3e17-a1d0-c94d35b2e5aa",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "e41a6db3_26cad648",
        "filename": "googleapi/chunker.go",
        "patchSetId": 17
      },
      "lineNbr": 78,
      "author": {
        "id": 5815
      },
      "writtenOn": "2015-08-14T21:41:54Z",
      "side": 1,
      "message": "Right. Will remove.",
      "parentUuid": "64303d13_4254122b",
      "revId": "3d02b69e1297c23ee83c3eed11b897b2fb871d42",
      "serverId": "c958e1eb-c711-3e17-a1d0-c94d35b2e5aa",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "e41a6db3_c6c4a238",
        "filename": "googleapi/googleapi.go",
        "patchSetId": 17
      },
      "lineNbr": 51,
      "author": {
        "id": 5815
      },
      "writtenOn": "2015-08-14T21:41:54Z",
      "side": 1,
      "message": "The original resumable upload implementation had mediaType as a mandatory parameter, so I\u0027ve kept it at first and then converted it to an UploadOption. But perhaps we should reconsider this.\n\nPresently Media and ResumableMedia use two different mechanisms for overriding automatic content type detection:\n- Media checks whether Reader implements googleapi.ContentTyper interface\n- ResumableMedia looks for UploadOption\n\nNote also that user may attempt to specify contentType as object resource/metadata: https://cloud.google.com/storage/docs/json_api/v1/objects/insert\nCurrent implementation of both regular and resumable upload will send this as JSON payload, but will effectively override it with auto-guessed value through HTTP headers.\n\nI suggest we remove both ContentTyper interface and SetMediaType UploadOption, and instead use contentType field in object resource if present, falling back to http.DetectContentType.\n\nOne caveat with this proposal is that I am only familiar with cloud storage API; I am not sure if other APIs that support upload also support contentType object resource field.",
      "range": {
        "startLine": 51,
        "startChar": 5,
        "endLine": 51,
        "endChar": 17
      },
      "revId": "3d02b69e1297c23ee83c3eed11b897b2fb871d42",
      "serverId": "c958e1eb-c711-3e17-a1d0-c94d35b2e5aa",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "449df96e_b1646015",
        "filename": "googleapi/googleapi.go",
        "patchSetId": 17
      },
      "lineNbr": 51,
      "author": {
        "id": 5505
      },
      "writtenOn": "2015-08-17T10:19:41Z",
      "side": 1,
      "message": "We can\u0027t assume that there is a contentType field in the object resource.  The Drive API, for example has no such field in its \"File\" resource: http://godoc.org/google.golang.org/api/drive/v2#File\n\nIn general, I think that the client library code should not care about the contents of the resources that it is dealing with.\n\nGiven that we can\u0027t rely on a resource contentType field, I don\u0027t think falling back to http.DetectContentType is enough: users need a way to explicitly specify the content type.\n\nI think it would be desirable to have consistency between Media and ResumableMedia.  My preference is to standardize on the approach we\u0027ve adopted for ResumableMedia in this change, so have Media take a variable number of UploadOptions.  If the user passes a setMediaType option into Media, it can override any ContentType method that the reader may have.  The use of ContentTyper doesn\u0027t seem to be documented, so I don\u0027t think this should be too confusing.  This way we don\u0027t break existing users of Media, but make ResumableMedia and Media consistent with each other.\n\nAlso, I think it\u0027s better to have a single exported UploadOption interface for both Media and ResumableMedia, rather than splitting it into MediaUploadOption and ResumableMediaUploadOption.  It makes it potentially easier to write common code, plus naming of the options is more straightforward.\n\nIf a user passes an UploadOption that is not relevant (such as a setChunkSize for Media), it could be ignored. Under the hood, this would mean that you would want two unexported interfaces, mediaUploadOption, with a method for populating a Media-specific option struct, and resumableMediaUploadOption, with a method for populating a ResumableMedia-specific option struct.",
      "parentUuid": "e41a6db3_c6c4a238",
      "range": {
        "startLine": 51,
        "startChar": 5,
        "endLine": 51,
        "endChar": 17
      },
      "revId": "3d02b69e1297c23ee83c3eed11b897b2fb871d42",
      "serverId": "c958e1eb-c711-3e17-a1d0-c94d35b2e5aa",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "e41a6db3_a6a9a615",
        "filename": "googleapi/googleapi.go",
        "patchSetId": 17
      },
      "lineNbr": 51,
      "author": {
        "id": 5815
      },
      "writtenOn": "2015-08-17T18:52:15Z",
      "side": 1,
      "message": "OK, I\u0027ll add ...UploadOption to Media(). I think I\u0027ll keep single unexported interface under the hood, and single struct holding union of options applying to Media and ResumableMedia. The relevant functions specific to Media/ResumableMedia will then use only those fields from the struct that are applicable to that upload type.",
      "parentUuid": "449df96e_b1646015",
      "range": {
        "startLine": 51,
        "startChar": 5,
        "endLine": 51,
        "endChar": 17
      },
      "revId": "3d02b69e1297c23ee83c3eed11b897b2fb871d42",
      "serverId": "c958e1eb-c711-3e17-a1d0-c94d35b2e5aa",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "e41a6db3_06bb5a5e",
        "filename": "googleapi/googleapi.go",
        "patchSetId": 17
      },
      "lineNbr": 402,
      "author": {
        "id": 5815
      },
      "writtenOn": "2015-08-17T18:52:15Z",
      "side": 1,
      "message": "This is wrong. An error from ChunkAt() (which would typically be an underlying reader error) would be swallowed, returning an \"application/octet-stream\" and relying on future invocations of ChunktAt to return the same error. But that\u0027s not guaranteed, since the underlying reader is not guaranteed to return the same error in the future.\n\nI think I\u0027ll modify Configure() to return an error, and modify the calling code to terminate upload on error.\n\nIt\u0027s worth noting that regular Media upload also needs to deal with the same issue, yet they chose very different approach. See getMediaType(): instead of propagating error as return value from the func, getMediaType is setting up an io.Pipe and a go routine to copy content from io.MultiReader to the pipe, all for the purpose of propagating the reader error out of io.Pipe. Why go through all that trouble when the end result will be failed upload? Why not just return error from getMediaType and terminate the upload in the caller using the returned error?",
      "range": {
        "startLine": 402,
        "startChar": 2,
        "endLine": 402,
        "endChar": 68
      },
      "revId": "3d02b69e1297c23ee83c3eed11b897b2fb871d42",
      "serverId": "c958e1eb-c711-3e17-a1d0-c94d35b2e5aa",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "e41a6db3_66edeeb1",
        "filename": "googleapi/googleapi.go",
        "patchSetId": 17
      },
      "lineNbr": 472,
      "author": {
        "id": 5815
      },
      "writtenOn": "2015-08-14T21:41:54Z",
      "side": 1,
      "message": "Note that this means that transient connection issues will cause the resumable upload to be aborted. In fact, the only scenario where resumable upload is actually resumed is if cloud storage server returns http code other than 308 and 200, which typically means 5xx.\n\nA more complete approach would be to try to distinguish between potentially transient errors (e.g. connectivity) and permanent errors (e.g. reader error) and implement a retry schema with an exponential backoff.\n\nThese are issues inherited from the initial implementation and are not in any way related to the added support for readers of unknown size, so I am not suggesting fixing them as part of this change set. I just thought this would be a good time to bring this up to everyone\u0027s attention.",
      "range": {
        "startLine": 472,
        "startChar": 3,
        "endLine": 472,
        "endChar": 18
      },
      "revId": "3d02b69e1297c23ee83c3eed11b897b2fb871d42",
      "serverId": "c958e1eb-c711-3e17-a1d0-c94d35b2e5aa",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "449df96e_d14ac479",
        "filename": "googleapi/googleapi.go",
        "patchSetId": 17
      },
      "lineNbr": 472,
      "author": {
        "id": 5505
      },
      "writtenOn": "2015-08-17T10:19:41Z",
      "side": 1,
      "message": "Thanks for pointing that out.  I agree that it would be good to make this more robust and that it should not be part of this change.  Can you file an issue to track this?",
      "parentUuid": "e41a6db3_66edeeb1",
      "range": {
        "startLine": 472,
        "startChar": 3,
        "endLine": 472,
        "endChar": 18
      },
      "revId": "3d02b69e1297c23ee83c3eed11b897b2fb871d42",
      "serverId": "c958e1eb-c711-3e17-a1d0-c94d35b2e5aa",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "e41a6db3_461712d5",
        "filename": "googleapi/googleapi.go",
        "patchSetId": 17
      },
      "lineNbr": 472,
      "author": {
        "id": 5815
      },
      "writtenOn": "2015-08-17T18:52:15Z",
      "side": 1,
      "message": "Looks like Glenn keeps an issue open for resumable upload support, so I\u0027ve added a comment there instead of creating yet another issue:\nhttps://github.com/google/google-api-go-client/issues/17",
      "parentUuid": "449df96e_d14ac479",
      "range": {
        "startLine": 472,
        "startChar": 3,
        "endLine": 472,
        "endChar": 18
      },
      "revId": "3d02b69e1297c23ee83c3eed11b897b2fb871d42",
      "serverId": "c958e1eb-c711-3e17-a1d0-c94d35b2e5aa",
      "unresolved": false
    }
  ]
}