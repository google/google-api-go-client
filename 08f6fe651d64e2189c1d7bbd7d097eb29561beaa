{
  "comments": [
    {
      "key": {
        "uuid": "6565d2f4_0904c970",
        "filename": "iterator/iterator.go",
        "patchSetId": 3
      },
      "lineNbr": 48,
      "author": {
        "id": 7675
      },
      "writtenOn": "2016-08-25T05:28:02Z",
      "side": 1,
      "message": "I\u0027m not sure if it\u0027s possible for GRPC streaming methods to implement this without serious contortions. In GRPC streaming, it is not possible to change page size or manually change page token midway.\n\nOne way to implement this is to make GRPC streaming methods detect when pageSize or pageToken changes, hang up, and make a new one. I think we should stay away from doing this though, since it misses the point of using streams.\n\nAside from things like that, I\u0027m not sure if GRPC streaming can be made to work with NextPage in general. Let\u0027s take bigtable.ReadRows as an example. The method returns some number of responses, each response contains at most pageSize rows and a pageToken.\n\nLet\u0027s say the user asks for exactly 5 rows. In the first response, we get back 3. We can\u0027t change pageSize of the stream, and we don\u0027t want to make a new stream, so we have to just received another response from the same stream. Let\u0027s also say the second response also contains 3 rows. How do we get the user the 5 rows now? Surely we can\u0027t just give them 3 or 6. We can take the first 2 rows out of second response to make 5, then store the last one somewhere. But what pageToken do we return? If we return the one from the first response, user will re-iterate over the 2 rows in the second. If we return the one from the second, the user will miss the last row. We\u0027re in a bit of a no-win situation.\n\nI see 3 options (I confess I\u0027m not very creative, there might be more)\n\n1. Don\u0027t implement exact-size iteration for either paging and streaming methods. Users might not even need it in the common case (I don\u0027t have the data), and they can do it themselves in the cases where they do.\n\n2. Let streaming methods hangup the stream and create new ones when pageSize and pageToken changes.\n\n3. Don\u0027t unify streaming and paging methods, after all they are different things. They can just share the Next() method. I am increasingly in favor of this option. Explained below.\n\njba@ asked if I have examples other than bigtable. I do not. In https://github.com/googleapis/googleapis , bigtable is the only service that has GRPC-streaming-with-page-token methods. There are other services with streaming methods, but they are different. In Genomics, responses don\u0027t have pageToken, so it\u0027s even more difficult to make it fit with pagination. In Speech, we have 2-way streaming, and so simply iterating over the results doesn\u0027t even make sense.\n\nWith the limited number and varied nature of GRPC streaming methods, we might be prematurely abstracting here.",
      "revId": "08f6fe651d64e2189c1d7bbd7d097eb29561beaa",
      "serverId": "c958e1eb-c711-3e17-a1d0-c94d35b2e5aa",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "6565d2f4_a9449da7",
        "filename": "iterator/iterator.go",
        "patchSetId": 3
      },
      "lineNbr": 48,
      "author": {
        "id": 5140
      },
      "writtenOn": "2016-08-25T06:21:25Z",
      "side": 1,
      "message": "For bigtable+gRPC, are we talking specifically about https://godoc.org/google.golang.org/genproto/googleapis/bigtable/v2#ReadRowsResponse and #Bigtable_ReadRowsClient?\n\nAFAICT, it doesn\u0027t actually support paging – at least not in a sense that I understand. Which page tokens are you seeing?\n\nIt would be really nice if the 1P folk could mandate that streaming APIs don\u0027t page – it really doesn\u0027t make sense in the context of a streaming API anyway and, as we\u0027ve seen here, doesn\u0027t fit the pattern we\u0027re using.\n\nI agree that (1) makes sense in the case where it\u0027s difficult to re-size pages. (2) is right out. (3) is probably right – but it would be good for that to be a criteria API authors / 1P enforcers use when deciding on whether a response should be streamed.",
      "parentUuid": "6565d2f4_0904c970",
      "revId": "08f6fe651d64e2189c1d7bbd7d097eb29561beaa",
      "serverId": "c958e1eb-c711-3e17-a1d0-c94d35b2e5aa",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "853726da_923b3cc7",
        "filename": "iterator/iterator.go",
        "patchSetId": 3
      },
      "lineNbr": 48,
      "author": {
        "id": 7715
      },
      "writtenOn": "2016-08-25T11:08:53Z",
      "side": 1,
      "message": "tl;dr: (3)\n\nThanks for thinking about this.\n\nIf an iterator can\u0027t support paging in the sense of this package, it shouldn\u0027t implement PageInfo. That is straightforward for simple streaming iterators like Genomics\u0027s StreamReads. The iterator for that should follow the guidelines for Next and use iterator.Done, but nothing else from this package.\n\nFor cases like BigTable where you can have a page size and token but only initially, I would just encode those as options to the iterator-creating function and provide an ad-hoc way to get the page token out. As you point out, you can\u0027t do exact paging correctly in that case, so it would be misleading at the least to implement PageInfo.\n\nExact paging is a strong request of JJ\u0027s, so I\u0027m unwilling to abandon it.",
      "parentUuid": "6565d2f4_0904c970",
      "revId": "08f6fe651d64e2189c1d7bbd7d097eb29561beaa",
      "serverId": "c958e1eb-c711-3e17-a1d0-c94d35b2e5aa",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "853726da_b23e40b7",
        "filename": "iterator/iterator.go",
        "patchSetId": 3
      },
      "lineNbr": 48,
      "author": {
        "id": 7715
      },
      "writtenOn": "2016-08-25T11:08:53Z",
      "side": 1,
      "message": "I do hope you were referencing https://www.youtube.com/watch?v\u003dxOrgLj9lOwk\u0026feature\u003dyoutu.be\u0026t\u003d108 and not just using the Queen\u0027s English.",
      "parentUuid": "6565d2f4_a9449da7",
      "revId": "08f6fe651d64e2189c1d7bbd7d097eb29561beaa",
      "serverId": "c958e1eb-c711-3e17-a1d0-c94d35b2e5aa",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "6565d2f4_e9e615dd",
        "filename": "iterator/iterator.go",
        "patchSetId": 3
      },
      "lineNbr": 138,
      "author": {
        "id": 7675
      },
      "writtenOn": "2016-08-25T05:28:02Z",
      "side": 1,
      "message": "Should we allow pageSize to be 0? If the size is 0, the server decides how many results to return (https://g3doc.corp.google.com/google/g3doc/style/design_patterns.md?cl\u003dhead#Pagination). This might be useful for \"just give me the next batch, I don\u0027t care how many\". I don\u0027t know how common this use case is though.",
      "revId": "08f6fe651d64e2189c1d7bbd7d097eb29561beaa",
      "serverId": "c958e1eb-c711-3e17-a1d0-c94d35b2e5aa",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "6565d2f4_89dd5909",
        "filename": "iterator/iterator.go",
        "patchSetId": 3
      },
      "lineNbr": 169,
      "author": {
        "id": 7675
      },
      "writtenOn": "2016-08-25T05:28:02Z",
      "side": 1,
      "message": "Isn\u0027t this nil pointer-to-slice and not nil slice? In my head,\n\n  var nilSlice []int\n  var nilPointerToSlice *[]int\n\nIt should be possible to append to nilSlice: https://play.golang.org/p/vVqthFXCqA",
      "revId": "08f6fe651d64e2189c1d7bbd7d097eb29561beaa",
      "serverId": "c958e1eb-c711-3e17-a1d0-c94d35b2e5aa",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "6565d2f4_89c4393f",
        "filename": "iterator/iterator.go",
        "patchSetId": 3
      },
      "lineNbr": 178,
      "author": {
        "id": 7675
      },
      "writtenOn": "2016-08-25T05:28:02Z",
      "side": 1,
      "message": "Shouldn\u0027t this go before\n\n  wantSliceType :\u003d ...\n\n? IIUC, after we call takeBuf(), bufLen() is always 0.",
      "range": {
        "startLine": 178,
        "startChar": 1,
        "endLine": 178,
        "endChar": 27
      },
      "revId": "08f6fe651d64e2189c1d7bbd7d097eb29561beaa",
      "serverId": "c958e1eb-c711-3e17-a1d0-c94d35b2e5aa",
      "unresolved": false
    }
  ]
}