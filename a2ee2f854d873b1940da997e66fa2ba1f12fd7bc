{
  "comments": [
    {
      "key": {
        "uuid": "0da7a2c0_de4ba97b",
        "filename": "googleapi/googleapi.go",
        "patchSetId": 11
      },
      "lineNbr": 46,
      "author": {
        "id": 5155
      },
      "writtenOn": "2015-07-27T18:03:02Z",
      "side": 1,
      "message": "Since this is still exported from the package, it should probably also have a comment dedicated to it.",
      "revId": "a2ee2f854d873b1940da997e66fa2ba1f12fd7bc",
      "serverId": "c958e1eb-c711-3e17-a1d0-c94d35b2e5aa",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "6dae5efb_32529035",
        "filename": "googleapi/googleapi.go",
        "patchSetId": 11
      },
      "lineNbr": 498,
      "author": {
        "id": 5505
      },
      "writtenOn": "2015-07-28T07:02:10Z",
      "side": 1,
      "message": "As documented, fakeReaderAt does not faithfully implement the io.ReaderAt interface, as it requires that reads be performed sequentially.  NewSectionReader makes no claims that it reads sequentially, even though that is how it is currently implemented. So supplying a fakeReaderAt here seems brittle.\n\nI think that you should define a new interface, \"sequentialReaderAt\", which defines the contract that you have described in the fakeReaderAt documentation. fakeReaderAt would become an implementation of sequentialReaderAt.\n\nThen, implement your own partial version of SectionReader which takes a sequentialReaderAt, and provides just a Read method (which is all you need for http.NewRequest).\n\n\nFurthermore, it should be easy to introduce an implementation of sequentialReaderAt which wraps a ReaderAt whose size is known (either because it satisfies the fileLike interface or because the caller has supplied an explicit size), let\u0027s call it \"sizedReaderAt\".  The necessary SizeAt method should be pretty straightforward if you just keep track of the size as determined in Configure.  This means that you can then make rx.Media be of type sequentialReaderAt, and get rid of the type assertion above.  The two if/else branches starting at line 478 could be combined into a single flow of logic.  It should just involve a few minor changes:\n\n* ensure that chunkSize is correctly set before transferChunks is called.  It looks like this is already the case, because you always set rx.ChunkSize on line 416.  This means that you can get rid of lines 480..482.  It also means that you can trust rx.chunkSize \u003d\u003d 0 to mean \"no chunking\".\n\n* make a change to SizeAt to treat a size of 0 as meaning \"return the size of the rest of the data\".\n\nThis way you can set reqSize by calling SizeAt regardless of whether it\u0027s implemented by a fakeReaderAt or sizedReaderAt.\n\nYou can also unconditionally set rx.ContentLength when you see EOF, regardless of the implementation of sequentialReaderAt.  However, I don\u0027t think you actually need to keep track of ContentLength as part of ResumableUpload.  You could add a function, \"Size\" to sequentialReaderAt which returns the overall size of the data if it is known (i.e. return (int64, ok) where ok is true once the stream has reached EOF).",
      "range": {
        "startLine": 498,
        "startChar": 10,
        "endLine": 498,
        "endChar": 26
      },
      "revId": "a2ee2f854d873b1940da997e66fa2ba1f12fd7bc",
      "serverId": "c958e1eb-c711-3e17-a1d0-c94d35b2e5aa",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "6dae5efb_15c49683",
        "filename": "googleapi/googleapi.go",
        "patchSetId": 11
      },
      "lineNbr": 498,
      "author": {
        "id": 5815
      },
      "writtenOn": "2015-07-28T18:10:09Z",
      "side": 1,
      "message": "Your io.SectionReader comment made me realize I have a serious bug, not just brittle code. SectionReader implements io.Reader by invoking embedded io.ReaderAt with progressively advancing offset. But my fakeReaderAt releases buffered content each time when offset is advanced, which means that there is a scenario where resuming download will fail due to fakeReaderAt not being able to go back far enough.\n\nThe only reason my tests did not catch this was that I used small enough test content size that the underlying io.Copy() read the entire content in a single Read() call.\n\nI will need to change fakeReaderAt to release buffered content only when SizeAt() is called, or perhaps to introduce explicit method for releasing content. Not only that this would fix this bug, it will also make it perfectly valid to use io.SectionReader without making any assumptions about its implementation.\n\nI should be able to fold in the rest of your suggested changes. Thanks!",
      "parentUuid": "6dae5efb_32529035",
      "range": {
        "startLine": 498,
        "startChar": 10,
        "endLine": 498,
        "endChar": 26
      },
      "revId": "a2ee2f854d873b1940da997e66fa2ba1f12fd7bc",
      "serverId": "c958e1eb-c711-3e17-a1d0-c94d35b2e5aa",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "6dae5efb_12682ce5",
        "filename": "googleapi/googleapi.go",
        "patchSetId": 11
      },
      "lineNbr": 527,
      "author": {
        "id": 5505
      },
      "writtenOn": "2015-07-28T07:02:10Z",
      "side": 1,
      "message": "\"roundChunkSize\" might be a better name.",
      "range": {
        "startLine": 527,
        "startChar": 5,
        "endLine": 527,
        "endChar": 18
      },
      "revId": "a2ee2f854d873b1940da997e66fa2ba1f12fd7bc",
      "serverId": "c958e1eb-c711-3e17-a1d0-c94d35b2e5aa",
      "unresolved": false
    }
  ]
}