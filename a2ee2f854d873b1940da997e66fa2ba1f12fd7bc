{
  "comments": [
    {
      "key": {
        "uuid": "0da7a2c0_de4ba97b",
        "filename": "googleapi/googleapi.go",
        "patchSetId": 11
      },
      "lineNbr": 46,
      "author": {
        "id": 5155
      },
      "writtenOn": "2015-07-27T18:03:02Z",
      "side": 1,
      "message": "Since this is still exported from the package, it should probably also have a comment dedicated to it.",
      "revId": "a2ee2f854d873b1940da997e66fa2ba1f12fd7bc",
      "serverId": "c958e1eb-c711-3e17-a1d0-c94d35b2e5aa",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "6dae5efb_32529035",
        "filename": "googleapi/googleapi.go",
        "patchSetId": 11
      },
      "lineNbr": 498,
      "author": {
        "id": 5505
      },
      "writtenOn": "2015-07-28T07:02:10Z",
      "side": 1,
      "message": "As documented, fakeReaderAt does not faithfully implement the io.ReaderAt interface, as it requires that reads be performed sequentially.  NewSectionReader makes no claims that it reads sequentially, even though that is how it is currently implemented. So supplying a fakeReaderAt here seems brittle.\n\nI think that you should define a new interface, \"sequentialReaderAt\", which defines the contract that you have described in the fakeReaderAt documentation. fakeReaderAt would become an implementation of sequentialReaderAt.\n\nThen, implement your own partial version of SectionReader which takes a sequentialReaderAt, and provides just a Read method (which is all you need for http.NewRequest).\n\n\nFurthermore, it should be easy to introduce an implementation of sequentialReaderAt which wraps a ReaderAt whose size is known (either because it satisfies the fileLike interface or because the caller has supplied an explicit size), let\u0027s call it \"sizedReaderAt\".  The necessary SizeAt method should be pretty straightforward if you just keep track of the size as determined in Configure.  This means that you can then make rx.Media be of type sequentialReaderAt, and get rid of the type assertion above.  The two if/else branches starting at line 478 could be combined into a single flow of logic.  It should just involve a few minor changes:\n\n* ensure that chunkSize is correctly set before transferChunks is called.  It looks like this is already the case, because you always set rx.ChunkSize on line 416.  This means that you can get rid of lines 480..482.  It also means that you can trust rx.chunkSize \u003d\u003d 0 to mean \"no chunking\".\n\n* make a change to SizeAt to treat a size of 0 as meaning \"return the size of the rest of the data\".\n\nThis way you can set reqSize by calling SizeAt regardless of whether it\u0027s implemented by a fakeReaderAt or sizedReaderAt.\n\nYou can also unconditionally set rx.ContentLength when you see EOF, regardless of the implementation of sequentialReaderAt.  However, I don\u0027t think you actually need to keep track of ContentLength as part of ResumableUpload.  You could add a function, \"Size\" to sequentialReaderAt which returns the overall size of the data if it is known (i.e. return (int64, ok) where ok is true once the stream has reached EOF).",
      "range": {
        "startLine": 498,
        "startChar": 10,
        "endLine": 498,
        "endChar": 26
      },
      "revId": "a2ee2f854d873b1940da997e66fa2ba1f12fd7bc",
      "serverId": "c958e1eb-c711-3e17-a1d0-c94d35b2e5aa",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "6dae5efb_12682ce5",
        "filename": "googleapi/googleapi.go",
        "patchSetId": 11
      },
      "lineNbr": 527,
      "author": {
        "id": 5505
      },
      "writtenOn": "2015-07-28T07:02:10Z",
      "side": 1,
      "message": "\"roundChunkSize\" might be a better name.",
      "range": {
        "startLine": 527,
        "startChar": 5,
        "endLine": 527,
        "endChar": 18
      },
      "revId": "a2ee2f854d873b1940da997e66fa2ba1f12fd7bc",
      "serverId": "c958e1eb-c711-3e17-a1d0-c94d35b2e5aa",
      "unresolved": false
    }
  ]
}